generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Company {
  id          String   @id @default(uuid())
  nome        String
  code        String   @unique
  plan        String   // 'free_trial', 'starter', 'professional', 'enterprise'
  logo        String?  // URL del logo aziendale

  // Gestione abbonamento
  planStatus       String    @default("active") // 'active', 'expired', 'cancelled'
  trialEndsAt      DateTime? // Data fine free trial
  subscriptionEndsAt DateTime? // Data scadenza abbonamento
  nextRenewalDate  DateTime? // Data prossimo rinnovo

  // Dati di fatturazione
  partitaIva       String?
  codiceFiscale    String?
  indirizzo        String?
  citta            String?
  cap              String?
  paese            String?
  telefono         String?
  emailFatturazione String?
  pec              String?
  codiceSdi        String?

  adminUserId String?  @unique
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  users       User[]      @relation("CompanyUsers")
  admin       User?       @relation(name: "CompanyAdmin", fields: [adminUserId], references: [id], onDelete: SetNull)
  videoRooms  VideoRoom[] @relation("CompanyVideoRooms")
  roles       Role[]      @relation("CompanyRoles")
  ticketCategories TicketCategory[] @relation("CompanyTicketCategories")
  roleChangeRequests RoleChangeRequest[] @relation("CompanyRoleChangeRequests")
  rewards     Reward[]    @relation("CompanyRewards")
}

model Role {
  id          String   @id @default(uuid())
  nome        String
  descrizione String?
  permessi    String   @default("{}")
  colore      String?  @default("#6366f1") // Colore per UI
  icona       String?  // Nome icona lucide-react
  isCustom    Boolean  @default(false)
  isSystem    Boolean  @default(false) // true per ruoli default (admin, dipendente)

  // Collegamento azienda per ruoli custom
  companyId   String?
  company     Company? @relation("CompanyRoles", fields: [companyId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  users       User[]
  ticketCategories TicketCategory[] @relation("RoleTicketCategories")
  roleChangeRequests RoleChangeRequest[] @relation("TargetRole")

  @@unique([nome, companyId])
  @@index([companyId])
  @@index([isCustom])
}

model Team {
  id          String   @id @default(uuid())
  nome        String   @unique
  descrizione String?
  colore      String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  users       User[]
  tasks       Task[]
}

model User {
  id            String        @id @default(uuid())
  email         String        @unique
  password      String
  nome          String
  cognome       String
  avatar        String?
  telefono      String?
  indirizzo     String?
  citta         String?
  cap           String?
  paese         String?

  roleId        String
  role          Role          @relation(fields: [roleId], references: [id])

  teamId        String?
  team          Team?         @relation(fields: [teamId], references: [id])

  // dipendente di un'azienda (N:1)
  companyId     String?
  company       Company?      @relation("CompanyUsers", fields: [companyId], references: [id])

  // admin di un'azienda (1:1, lato opposto senza campi)
  adminCompany  Company?      @relation("CompanyAdmin")

  // 'pending' | 'approved' | 'rejected'
  status        String        @default("approved")

  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  auditLogs        AuditLog[]
  tasksOwned       Task[]           @relation("TaskOwner")
  tasksAssigned    Task[]           @relation("TaskAssignees")
  comments         Comment[]
  worklogs         TaskWorklog[]
  workSessions     WorkSession[]
  requests         Request[]
  requestRisposte  RequestRisposta[]
  scores           Score[]
  teamScores       TeamScore[]
  ticketsCreated   Ticket[]         @relation("TicketAuthor")
  ticketsAssigned  Ticket[]         @relation("TicketAssignee")
  ticketsTaken     Ticket[]         @relation("TicketTakenBy")
  ticketRisposte   TicketRisposta[]
  notifications    Notification[]
  eventsOrganized  CalendarEvent[]  @relation("EventOrganizer")
  eventsParticipating CalendarEvent[] @relation("EventParticipants")
  emails           Email[]
  calendarConnections CalendarConnection[]
  emailAccounts    EmailAccount[]
  videoRoomsCreated VideoRoom[]      @relation("RoomCreator")
  notes            Note[]           @relation("NoteAuthor")
  roleChangeRequests RoleChangeRequest[] @relation("UserRoleChangeRequests")
  roleChangeRequestsReviewed RoleChangeRequest[] @relation("ReviewedRoleChangeRequests")
  rewardRedemptions RewardRedemption[] @relation("UserRedemptions")
  chatMessages     ChatMessage[]    @relation("ChatMessageAuthor")
  projectsOwned    Progetto[]       @relation("ProjectOwner")
  directMessagesSent DirectMessage[] @relation("DirectMessageSender")
  directMessagesReceived DirectMessage[] @relation("DirectMessageReceiver")
  foldersOwned     Folder[]         @relation("FolderOwner")
  sharedFolders    FolderShare[]    @relation("SharedFolders")
  videoRoomMessages VideoRoomMessage[] @relation("UserVideoRoomMessages")

  @@index([companyId])
  @@index([status])
}

model Progetto {
  id          String   @id @default(uuid())
  nome        String
  descrizione String?
  colore      String?  @default("#3B82F6")

  // Stato del progetto
  stato       String   @default("in_progress") // 'in_progress', 'completed', 'archived'
  progresso   Int      @default(0) // 0-100% calcolato automaticamente
  isActive    Boolean  @default(false) // Se true, il progetto è attivo e le task possono essere lavorate

  // Reward system
  rewardPoints    Int      @default(500) // Punti da distribuire al completamento
  rewardDistributed Boolean @default(false) // Se i premi sono già stati distribuiti

  // Organizzazione gerarchica (cartelle)
  parentId    String?
  parent      Progetto?  @relation("SubProjects", fields: [parentId], references: [id], onDelete: Cascade)
  subProjects Progetto[] @relation("SubProjects")
  isFolder    Boolean    @default(false) // true se è una cartella, false se è un progetto

  // Cartella collegata nel Drive (ogni progetto = una cartella automatica)
  driveFolderId String?  @unique // Cartella automatica nel Drive per documenti del progetto

  // Owner e membri del team
  ownerId     String
  owner       User       @relation("ProjectOwner", fields: [ownerId], references: [id])

  // Membri del progetto (array JSON di user IDs)
  memberIds   String     @default("[]") // Array JSON di user IDs del team

  // Contatti associati (array JSON di contact IDs)
  contactIds  String     @default("[]") // Array JSON di contact IDs

  // Azienda (isolamento dati)
  companyId   String

  // Date
  dataInizio  DateTime?
  scadenza    DateTime?
  dataCompletamento DateTime? // Quando è stato completato

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relazioni con altre entità
  tasks       Task[]
  notes       Note[]     @relation("ProjectNotes")
  documents   Document[] @relation("ProjectDocuments")
  events      CalendarEvent[] @relation("ProjectEvents")
  emails      Email[]    @relation("ProjectEmails")
  crms        CRMTemplate[] @relation("ProjectCRMs") // CRM collegati al progetto

  @@index([companyId])
  @@index([ownerId])
  @@index([parentId])
  @@index([stato])
  @@index([isFolder])
  @@index([isActive])
  @@index([driveFolderId])
}

model Task {
  id            String        @id @default(uuid())
  titolo        String
  descrizione   String?
  stato         String        @default("todo")
  priorita      String        @default("medium")
  difficolta    Int           @default(3)
  qualitaFinale Int?
  scadenza      DateTime?
  dataInizio    DateTime?
  dataFine      DateTime?

  // Reward system
  rewardPoints  Int           @default(50) // Punti base per completamento (default 50)
  rewardPerSubtask Int        @default(10) // Punti per ogni subtask completata (default 10)

  ownerId     String
  owner       User          @relation("TaskOwner", fields: [ownerId], references: [id])

  assignees   User[]        @relation("TaskAssignees")

  teamId      String?
  team        Team?         @relation(fields: [teamId], references: [id])

  progettoId  String?
  progetto    Progetto?     @relation(fields: [progettoId], references: [id])

  tags        String        @default("[]")
  checklist   String        @default("[]")
  contactIds  String        @default("[]") // Array JSON di contact IDs taggati
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  comments    Comment[]
  worklogs    TaskWorklog[]
  requests    Request[]
  scores      Score[]
  tickets     Ticket[]
  subtasks    Subtask[]
  calendarEvents CalendarEvent[]
  emails      Email[]
  documents   Document[]    @relation("TaskDocuments")

  @@index([ownerId])
  @@index([teamId])
  @@index([progettoId])
}

model Subtask {
  id          String   @id @default(uuid())
  titolo      String
  descrizione String?
  completata  Boolean  @default(false)
  ordine      Int      @default(0)

  taskId      String
  task        Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)

  workSessions WorkSession[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([taskId])
  @@index([completata])
}

model Comment {
  id        String   @id @default(uuid())
  taskId    String
  task      Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  autoreId  String
  autore    User     @relation(fields: [autoreId], references: [id])
  contenuto String
  menzioni  String   @default("[]")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([taskId])
  @@index([autoreId])
}

model TaskWorklog {
  id            String   @id @default(uuid())
  taskId        String
  task          Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  userId        String
  user          User     @relation(fields: [userId], references: [id])
  minuti        Int
  checklistDone String   @default("[]")
  note          String?
  createdAt     DateTime @default(now())

  @@index([taskId])
  @@index([userId])
}

// Sessioni di lavoro per tracking in tempo reale
model WorkSession {
  id          String   @id @default(uuid())

  // Riferimento alla subtask
  subtaskId   String
  subtask     Subtask  @relation(fields: [subtaskId], references: [id], onDelete: Cascade)

  // Riferimento all'utente
  userId      String
  user        User     @relation(fields: [userId], references: [id])

  // Stato della sessione
  stato       String   @default("active") // 'active', 'paused', 'completed'

  // Timing
  startedAt   DateTime @default(now())
  pausedAt    DateTime? // Quando è stata messa in pausa
  completedAt DateTime? // Quando è stata completata

  // Tempo accumulato in secondi (escludendo le pause)
  tempoAccumulato Int   @default(0)

  // Ultimo timestamp di calcolo (per riprendere dal punto giusto)
  lastUpdateAt DateTime @default(now())

  // Pause tracking
  totalePause  Int      @default(0) // Totale secondi in pausa
  pauseCount   Int      @default(0) // Numero di pause effettuate

  // Notifica pausa 1h
  ultimaNotificaPausa DateTime? // Ultima notifica di pausa inviata

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([subtaskId])
  @@index([userId])
  @@index([stato])
}

model Request {
  id          String   @id @default(uuid())
  tipo        String
  urgenza     String   @default("media")
  descrizione String
  stato       String   @default("aperta") // 'aperta', 'in_lavorazione', 'approvata', 'rifiutata'
  chiuso      Boolean  @default(false) // Se true, il ticket è chiuso e non può ricevere risposte
  autoreId    String
  autore      User     @relation(fields: [autoreId], references: [id])
  taskId      String?
  task        Task?    @relation(fields: [taskId], references: [id])
  risposte    RequestRisposta[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([autoreId])
  @@index([stato])
  @@index([chiuso])
}

model RequestRisposta {
  id          String   @id @default(uuid())
  requestId   String
  request     Request  @relation(fields: [requestId], references: [id], onDelete: Cascade)
  autoreId    String
  autore      User     @relation(fields: [autoreId], references: [id])
  contenuto   String
  isAdmin     Boolean  @default(false)
  createdAt   DateTime @default(now())

  @@index([requestId])
  @@index([autoreId])
}

model Score {
  id              String   @id @default(uuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id])
  taskId          String?  // Opzionale per permettere score non legati a task
  task            Task?    @relation(fields: [taskId], references: [id])
  puntiBase       Int
  punti           Int
  moltiplicatore  Float    @default(1.0)
  bonusPuntualita Float    @default(0.0)
  malusPuntualita Float    @default(0.0)
  puntiTotali     Int
  periodo         String?
  breakdown       String   @default("{}")
  tipo            String   @default("task_completion") // 'task_completion', 'daily_penalty', 'daily_bonus', 'activity_bonus'
  createdAt       DateTime @default(now())

  @@index([userId])
  @@index([taskId])
  @@index([createdAt])
  @@index([periodo])
  @@index([tipo])
}

// Penalità giornaliere per task scadute
model DailyPenalty {
  id          String   @id @default(uuid())
  userId      String
  taskId      String
  giornoRitardo Int    // Numero di giorni di ritardo
  puntPenalita Int     // Punti sottratti
  applicata   Boolean  @default(false) // Se è stata applicata allo score
  data        DateTime @default(now()) // Data in cui è stata calcolata

  @@index([userId])
  @@index([taskId])
  @@index([data])
  @@index([applicata])
  @@unique([userId, taskId, data]) // Una penalità per task per giorno
}

// Bonus giornalieri per attività
model DailyBonus {
  id          String   @id @default(uuid())
  userId      String
  tipo        String   // 'login', 'first_task', 'focus_time', 'collaboration', 'early_completion'
  punti       Int      // Punti bonus assegnati
  descrizione String?  // Descrizione del bonus
  data        DateTime @default(now())

  @@index([userId])
  @@index([tipo])
  @@index([data])
}

model Notification {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  tipo      String
  titolo    String
  messaggio String
  link      String?
  letta     Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([userId, letta])
}

model Ticket {
  id          String   @id @default(uuid())
  titolo      String
  descrizione String
  stato       String   @default("aperto") // 'aperto', 'in_lavorazione', 'risolto', 'chiuso'
  priorita    String   @default("media") // 'bassa', 'media', 'alta', 'urgente'

  // Categoria del ticket (routing automatico per ruolo)
  categoryId  String?
  category    TicketCategory? @relation(fields: [categoryId], references: [id])

  // Routing del ticket
  targetRoleId String?  // Ruolo target (da categoria o manuale)

  // Utente che ha aperto il ticket
  autoreId    String
  autore      User     @relation("TicketAuthor", fields: [autoreId], references: [id])

  // Task collegato (opzionale)
  taskId      String?
  task        Task?    @relation(fields: [taskId], references: [id])

  // Utente assegnato (può essere manual o chi "prende in carico")
  assignedToId String?
  assignedTo   User?   @relation("TicketAssignee", fields: [assignedToId], references: [id])

  // Preso in carico da (quando qualcuno del ruolo target prende il ticket)
  takenByUserId String?
  takenBy      User?    @relation("TicketTakenBy", fields: [takenByUserId], references: [id])
  takenAt      DateTime?

  // Azienda (isolamento)
  companyId    String?

  // Risposte al ticket
  risposte    TicketRisposta[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([autoreId])
  @@index([taskId])
  @@index([stato])
  @@index([assignedToId])
  @@index([categoryId])
  @@index([targetRoleId])
  @@index([takenByUserId])
  @@index([companyId])
}

model TicketRisposta {
  id        String   @id @default(uuid())
  ticketId  String
  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  autoreId  String
  autore    User     @relation(fields: [autoreId], references: [id])
  contenuto String
  isAdmin   Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([ticketId])
  @@index([autoreId])
}

// Categorie ticket per routing automatico
model TicketCategory {
  id          String   @id @default(uuid())
  nome        String   // es: "Problema Coding", "Richiesta HR"
  descrizione String?
  icona       String?  // Nome icona lucide-react
  colore      String?  @default("#6366f1")

  // Ruolo target per routing automatico
  targetRoleId String
  targetRole   Role    @relation("RoleTicketCategories", fields: [targetRoleId], references: [id])

  // Azienda
  companyId   String
  company     Company @relation("CompanyTicketCategories", fields: [companyId], references: [id], onDelete: Cascade)

  // Tickets con questa categoria
  tickets     Ticket[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([nome, companyId])
  @@index([companyId])
  @@index([targetRoleId])
}

// Richieste di cambio ruolo
model RoleChangeRequest {
  id          String   @id @default(uuid())

  // Utente richiedente
  userId      String
  user        User     @relation("UserRoleChangeRequests", fields: [userId], references: [id], onDelete: Cascade)

  // Ruolo attuale (snapshot)
  currentRoleName String

  // Ruolo richiesto
  requestedRoleId String
  requestedRole   Role   @relation("TargetRole", fields: [requestedRoleId], references: [id])

  // Motivazione
  motivazione String

  // Stato richiesta
  stato       String   @default("pending") // 'pending', 'approved', 'rejected'

  // Review
  reviewedBy  String?
  reviewer    User?    @relation("ReviewedRoleChangeRequests", fields: [reviewedBy], references: [id])
  reviewedAt  DateTime?
  reviewNote  String?  // Nota dell'admin

  // Azienda
  companyId   String
  company     Company  @relation("CompanyRoleChangeRequests", fields: [companyId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([requestedRoleId])
  @@index([stato])
  @@index([companyId])
  @@index([reviewedBy])
}

model TeamScore {
  id        String   @id @default(uuid())
  teamId    String
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  punti     Int
  periodo   String?
  createdAt DateTime @default(now())

  @@index([teamId])
  @@index([userId])
  @@index([periodo])
}

model AuditLog {
  id        String   @id @default(uuid())
  entita    String
  entitaId  String
  azione    String
  autoreId  String
  autore    User     @relation(fields: [autoreId], references: [id])
  payload   String   @default("{}")
  createdAt DateTime @default(now())

  @@index([entita, entitaId])
  @@index([autoreId])
}

// Sistema di note libere (tipo Notion/Whiteboard)
model Note {
  id          String   @id @default(uuid())
  titolo      String
  tipo        String   @default("text") // 'text', 'spreadsheet', 'whiteboard', 'transcription', 'ai_generated'
  contenuto   String   @default("") // Contenuto in formato HTML/Markdown/JSON
  categoria   String?  // Categoria personalizzata
  colore      String?  @default("#3B82F6") // Colore per organizzazione visiva
  tags        String   @default("[]") // Array JSON di tags

  // Proprietario della nota
  autoreId    String
  autore      User     @relation("NoteAuthor", fields: [autoreId], references: [id])

  // Condivisione
  isPublic    Boolean  @default(false) // Se true, visibile a tutti nella company
  sharedWith  String   @default("[]") // Array JSON di user IDs con cui è condivisa
  teamShared  String   @default("[]") // Array JSON di team IDs con cui è condivisa

  // Organizzazione
  isPinned    Boolean  @default(false) // Note fissate in alto
  isFavorite  Boolean  @default(false) // Note preferite
  isArchived  Boolean  @default(false) // Note archiviate

  // Collegamenti
  taskId      String?  // Task collegato (opzionale)
  progettoId  String?  // Progetto collegato (opzionale)
  progetto    Progetto? @relation("ProjectNotes", fields: [progettoId], references: [id])
  contactIds  String   @default("[]") // Array JSON di contact IDs taggati

  // AI Features
  aiGenerated     Boolean  @default(false) // Se la nota è stata generata dall'AI
  aiSummary       String?  // Riassunto generato dall'AI
  aiPrompt        String?  // Prompt usato per generare la nota (se AI generated)

  // Trascrizione videochiamate
  isTranscription Boolean  @default(false) // Se è una trascrizione
  videoCallId     String?  // ID della videochiamata (se trascrizione)
  audioUrl        String?  // URL del file audio originale
  transcriptionLang String? @default("it") // Lingua della trascrizione
  transcriptionDuration Int? // Durata in secondi
  speakers        String   @default("[]") // Array JSON di speaker identificati

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([autoreId])
  @@index([tipo])
  @@index([categoria])
  @@index([isPinned])
  @@index([isArchived])
  @@index([taskId])
  @@index([progettoId])
  @@index([aiGenerated])
  @@index([isTranscription])
  @@index([videoCallId])
}

model CalendarEvent {
  id          String   @id @default(uuid())
  titolo      String
  descrizione String?
  tipo        String   @default("meeting") // 'meeting', 'task', 'reminder', 'holiday'
  dataInizio  DateTime
  dataFine    DateTime
  luogo       String?
  linkMeeting String?  // Google Meet, Zoom, etc.
  allDay      Boolean  @default(false)
  colore      String?  @default("#3B82F6")

  // Organizzatore
  organizerId String
  organizer   User     @relation("EventOrganizer", fields: [organizerId], references: [id])

  // Partecipanti
  partecipanti User[]  @relation("EventParticipants")

  // Task collegato (opzionale)
  taskId      String?
  task        Task?    @relation(fields: [taskId], references: [id])

  // Progetto collegato (opzionale)
  progettoId  String?
  progetto    Progetto? @relation("ProjectEvents", fields: [progettoId], references: [id], onDelete: Cascade)

  // Contatti taggati
  contactIds  String   @default("[]") // Array JSON di contact IDs taggati

  // Notifiche
  reminderMinutes Int?  @default(15) // Minuti prima dell'evento

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([organizerId])
  @@index([dataInizio])
  @@index([taskId])
  @@index([progettoId])
}

model Email {
  id          String   @id @default(uuid())
  oggetto     String
  corpo       String
  mittente    String
  destinatari String   @default("[]") // Array JSON di email
  cc          String?  @default("[]")
  bcc         String?  @default("[]")

  // Stato email
  stato       String   @default("inviata") // 'bozza', 'inviata', 'ricevuta', 'letta', 'archiviata'
  importante  Boolean  @default(false)
  hasAttachment Boolean @default(false)

  // Utente proprietario (ricevente o mittente)
  userId      String
  user        User     @relation(fields: [userId], references: [id])

  // Task collegato (opzionale)
  taskId      String?
  task        Task?    @relation(fields: [taskId], references: [id])

  // Progetto collegato (opzionale)
  progettoId  String?
  progetto    Progetto? @relation("ProjectEmails", fields: [progettoId], references: [id], onDelete: Cascade)

  // Thread email
  threadId    String?  // Per raggruppare email correlate
  inReplyTo   String?  // ID email a cui si risponde

  dataInvio   DateTime @default(now())
  dataLettura DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([stato])
  @@index([taskId])
  @@index([progettoId])
  @@index([threadId])
  @@index([dataInvio])
}

// Connessioni Calendar esterne (Google Calendar, Outlook Calendar)
model CalendarConnection {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  provider    String   // 'google', 'outlook', 'apple'
  accountEmail String  // Email dell'account collegato
  accountName String?  // Nome visualizzato

  // OAuth2 tokens
  accessToken  String
  refreshToken String?
  tokenExpiry  DateTime?

  // Sync settings
  syncEnabled  Boolean  @default(true)
  lastSync     DateTime?
  calendarId   String?  // ID del calendario remoto

  // Metadata
  metadata     String   @default("{}")  // JSON per dati specifici del provider

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([provider])
  @@unique([userId, provider, accountEmail])
}

// Account Email esterni (Gmail, Outlook, IMAP, POP3)
model EmailAccount {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  provider    String   // 'gmail', 'outlook', 'imap', 'pop3'
  accountEmail String  // Indirizzo email dell'account
  accountName String?  // Nome visualizzato

  // OAuth2 tokens (per Gmail e Outlook)
  accessToken  String?
  refreshToken String?
  tokenExpiry  DateTime?

  // IMAP/POP3 settings
  imapHost     String?
  imapPort     Int?
  imapSecure   Boolean  @default(true)
  pop3Host     String?
  pop3Port     Int?
  pop3Secure   Boolean  @default(true)
  smtpHost     String?
  smtpPort     Int?
  smtpSecure   Boolean  @default(true)
  emailPassword String? // Encrypted password per IMAP/POP3

  // Sync settings
  syncEnabled  Boolean  @default(true)
  lastSync     DateTime?
  syncFrequency Int     @default(5) // minuti

  // Metadata
  metadata     String   @default("{}")  // JSON per dati specifici

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([userId])
  @@index([provider])
  @@unique([userId, accountEmail])
}

// Stanze per videochiamate (simile a canali Discord)
model VideoRoom {
  id          String   @id @default(uuid())
  nome        String
  descrizione String?
  tipo        String   @default("meeting") // 'meeting', 'team', 'public', 'private', 'scheduled'

  // Creatore della room
  creatoreId  String
  creatore    User     @relation("RoomCreator", fields: [creatoreId], references: [id])

  // Company associata (ISOLAMENTO DATI)
  companyId   String?
  company     Company? @relation("CompanyVideoRooms", fields: [companyId], references: [id])

  // Team associato (opzionale)
  teamId      String?

  // Impostazioni
  maxPartecipanti Int     @default(50)
  requiresAuth    Boolean @default(true)
  password        String? // Password opzionale per room private

  // Stato
  isActive    Boolean  @default(true)

  // Pianificazione
  scheduledAt DateTime? // Data/ora programmata

  // Integrazioni esterne
  meetingProvider String?  // 'native', 'zoom', 'google_meet'
  zoomMeetingId   String?  // ID meeting Zoom
  zoomJoinUrl     String?  // URL di join Zoom
  googleMeetUrl   String?  // URL Google Meet

  // Partecipanti invitati (per meeting programmati)
  invitedUserIds  String   @default("[]") // Array JSON di user IDs

  // Partecipanti e chiamate
  partecipanti VideoRoomParticipant[]
  chiamate     VideoCall[]
  messaggi     VideoRoomMessage[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([creatoreId])
  @@index([companyId])
  @@index([teamId])
  @@index([tipo])
  @@index([isActive])
  @@index([scheduledAt])
}

// Partecipanti nelle stanze
model VideoRoomParticipant {
  id          String   @id @default(uuid())

  roomId      String
  room        VideoRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)

  userId      String

  // Stato del partecipante
  isConnected Boolean  @default(false)
  isMuted     Boolean  @default(false)
  isVideoOff  Boolean  @default(false)

  joinedAt    DateTime @default(now())
  leftAt      DateTime?

  @@index([roomId])
  @@index([userId])
  @@unique([roomId, userId])
}

// Sessioni di videochiamata
model VideoCall {
  id          String   @id @default(uuid())

  roomId      String
  room        VideoRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)

  // Informazioni chiamata
  titolo      String
  descrizione String?

  // Orario
  scheduledAt DateTime? // Se programmata in anticipo
  startedAt   DateTime?
  endedAt     DateTime?

  // Stato
  stato       String   @default("scheduled") // 'scheduled', 'active', 'ended'

  // Recording (futuro)
  isRecording Boolean  @default(false)
  recordingUrl String?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([roomId])
  @@index([stato])
  @@index([scheduledAt])
}

// Messaggi chat nella room
model VideoRoomMessage {
  id          String   @id @default(uuid())

  roomId      String
  room        VideoRoom @relation(fields: [roomId], references: [id], onDelete: Cascade)

  userId      String
  user        User     @relation("UserVideoRoomMessages", fields: [userId], references: [id])

  messaggio   String
  tipo        String   @default("text") // 'text', 'system', 'emoji'

  createdAt   DateTime @default(now())

  @@index([roomId])
  @@index([userId])
  @@index([createdAt])
}

// Sistema di premi per gamificazione dipendenti
model Reward {
  id          String   @id @default(uuid())
  nome        String   // es: "iPhone 17 Pro Max"
  descrizione String?
  immagine    String?  // URL immagine del premio

  // Costi del premio
  costoScore      Int      // Punti totali richiesti (es: 10)
  costoMensile    Int      // Punti mensili richiesti (es: 5)

  // Disponibilità
  quantita        Int      @default(1) // Quantità disponibili (-1 = illimitato)
  disponibile     Boolean  @default(true) // Se disabilitato dall'admin

  // Azienda (isolamento)
  companyId   String
  company     Company  @relation("CompanyRewards", fields: [companyId], references: [id], onDelete: Cascade)

  // Riscatti del premio
  redemptions RewardRedemption[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([companyId])
  @@index([disponibile])
}

// Riscatti premi da parte dei dipendenti
model RewardRedemption {
  id          String   @id @default(uuid())

  // Premio riscattato
  rewardId    String
  reward      Reward   @relation(fields: [rewardId], references: [id], onDelete: Cascade)

  // Dipendente che ha riscattato
  userId      String
  user        User     @relation("UserRedemptions", fields: [userId], references: [id])

  // Stato del riscatto
  stato       String   @default("pending") // 'pending', 'approved', 'rejected', 'awaiting_pickup', 'delivered'

  // Note admin
  adminNote   String?

  // Metodo di ritiro
  metodoRitiro String? // 'consegna_casa', 'ritiro_persona'

  // Dati consegna (se metodoRitiro = 'consegna_casa')
  indirizzoConsegna String?
  cittaConsegna     String?
  capConsegna       String?
  telefonoConsegna  String?
  noteConsegna      String?

  // Azienda (isolamento)
  companyId   String

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([rewardId])
  @@index([userId])
  @@index([companyId])
  @@index([stato])
}

// Sistema di chat aziendale
model ChatMessage {
  id          String   @id @default(uuid())

  // Contenuto messaggio
  messaggio   String
  menzioni    String   @default("[]") // Array JSON di user IDs menzionati con @

  // Autore del messaggio
  autoreId    String
  autore      User     @relation("ChatMessageAuthor", fields: [autoreId], references: [id])

  // Azienda (isolamento dati)
  companyId   String

  // Stato messaggio
  modificato  Boolean  @default(false)
  eliminato   Boolean  @default(false)

  // Reactions (emoji reactions)
  reactions   String   @default("{}") // JSON: { "❤️": ["userId1", "userId2"], "👍": ["userId3"] }

  // Thread/Reply
  replyToId   String?
  replyTo     ChatMessage?  @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies     ChatMessage[] @relation("MessageReplies")

  // Allegati (opzionale - futuro)
  allegati    String   @default("[]") // Array JSON di URLs

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Tracciamento lettura
  readBy      ChatMessageRead[]

  @@index([companyId])
  @@index([autoreId])
  @@index([createdAt])
  @@index([replyToId])
}

// Tracciamento lettura messaggi chat
model ChatMessageRead {
  id          String   @id @default(uuid())

  messageId   String
  message     ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)

  userId      String

  readAt      DateTime @default(now())

  @@unique([messageId, userId])
  @@index([messageId])
  @@index([userId])
}

// Contatti globali (indipendenti da progetti)
model Contact {
  id          String   @id @default(uuid())
  nome        String
  cognome     String?
  email       String?
  emailAziendale String?
  telefono    String?
  telefonoCellulare String?
  azienda     String?
  ruolo       String?  // Ruolo nella loro azienda
  indirizzo   String?
  citta       String?
  cap         String?
  paese       String?
  sito        String?  // Sito web
  linkedin    String?  // Profilo LinkedIn
  note        String?
  tags        String   @default("[]") // Array JSON di tags
  avatar      String?  // URL avatar/foto

  // Collegamenti a task, progetti, note, eventi
  collegamenti String  @default("[]") // Array JSON di { tipo: 'task'|'progetto'|'nota'|'evento', id: string, titolo: string }

  // Creatore del contatto
  createdById String

  // Azienda (isolamento dati)
  companyId   String

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([companyId])
  @@index([email])
  @@index([emailAziendale])
  @@index([createdById])
}

// Cartelle per organizzare i documenti
model Folder {
  id          String   @id @default(uuid())
  nome        String
  descrizione String?
  colore      String?  @default("#3B82F6")

  // Gerarchia cartelle (opzionale)
  parentFolderId String?
  parentFolder   Folder?  @relation("FolderHierarchy", fields: [parentFolderId], references: [id], onDelete: Cascade)
  subFolders     Folder[] @relation("FolderHierarchy")

  // Proprietario della cartella
  ownerId     String
  owner       User     @relation("FolderOwner", fields: [ownerId], references: [id])

  // Azienda (isolamento dati)
  companyId   String

  // Condivisione
  sharedWith  FolderShare[]

  // Documenti nella cartella
  documents   Document[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([ownerId])
  @@index([companyId])
  @@index([parentFolderId])
}

// Condivisione cartelle con utenti
model FolderShare {
  id          String   @id @default(uuid())

  folderId    String
  folder      Folder   @relation(fields: [folderId], references: [id], onDelete: Cascade)

  userId      String
  user        User     @relation("SharedFolders", fields: [userId], references: [id], onDelete: Cascade)

  // Permessi
  canView     Boolean  @default(true)
  canEdit     Boolean  @default(false)
  canDelete   Boolean  @default(false)
  canShare    Boolean  @default(false)

  createdAt   DateTime @default(now())

  @@unique([folderId, userId])
  @@index([folderId])
  @@index([userId])
}

// Documenti per progetti e contatti
model Document {
  id          String   @id @default(uuid())
  nome        String
  descrizione String?
  tipo        String   // 'pdf', 'doc', 'xls', 'ppt', 'img', 'audio', 'video', 'archive', 'other'
  dimensione  Int?     // Dimensione in bytes
  url         String   // URL del file (storage esterno o locale)
  mimeType    String?  // MIME type del file

  // Versioning
  versione    String   @default("1.0")
  isLatest    Boolean  @default(true)
  parentDocId String?  // ID del documento padre (per versioning)

  // Cartella (opzionale)
  folderId    String?
  folder      Folder?  @relation(fields: [folderId], references: [id], onDelete: SetNull)

  // Collegamento progetto O contatto O task (opzionali, almeno uno deve essere presente)
  progettoId  String?
  progetto    Progetto? @relation("ProjectDocuments", fields: [progettoId], references: [id], onDelete: Cascade)

  contactId   String?  // Collegamento a contatto

  taskId      String?  // Collegamento a task
  task        Task?    @relation("TaskDocuments", fields: [taskId], references: [id], onDelete: Cascade)

  // Chi ha caricato
  uploadedById String

  // Azienda (isolamento dati)
  companyId   String

  // Tags e categorizzazione
  tags        String   @default("[]") // Array JSON di tags
  categoria   String?  // Categoria custom

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([folderId])
  @@index([progettoId])
  @@index([contactId])
  @@index([taskId])
  @@index([companyId])
  @@index([uploadedById])
  @@index([tipo])
  @@index([isLatest])
}

// Messaggi diretti tra utenti (chat 1-to-1)
model DirectMessage {
  id          String   @id @default(uuid())

  // Mittente e destinatario
  senderId    String
  sender      User     @relation("DirectMessageSender", fields: [senderId], references: [id])

  receiverId  String
  receiver    User     @relation("DirectMessageReceiver", fields: [receiverId], references: [id])

  // Contenuto messaggio
  messaggio   String

  // Stato messaggio
  letto       Boolean  @default(false)
  lettoAt     DateTime?
  modificato  Boolean  @default(false)
  eliminato   Boolean  @default(false)

  // Azienda (isolamento dati - entrambi devono essere della stessa azienda)
  companyId   String

  // Allegati (opzionale)
  allegati    String   @default("[]") // Array JSON di URLs

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([senderId])
  @@index([receiverId])
  @@index([companyId])
  @@index([createdAt])
  @@index([letto])
}

// ===================================
// SISTEMA CRM PERSONALIZZABILE
// ===================================

// Template CRM - Definisce un tipo di CRM con i suoi campi custom
model CRMTemplate {
  id          String   @id @default(uuid())
  nome        String   // es: "Tracciato Clienti Fondo Investimento"
  descrizione String?
  icona       String?  @default("Users") // Nome icona lucide-react
  colore      String?  @default("#3B82F6")
  nomeTabella String?  // Nome personalizzato per la tabella (default: "Record")

  // Creatore del CRM
  createdById String

  // Azienda (isolamento dati)
  companyId   String

  // Progetto collegato (opzionale)
  progettoId  String?
  progetto    Progetto? @relation("ProjectCRMs", fields: [progettoId], references: [id], onDelete: Cascade)

  // Campi personalizzati del CRM
  fields      CRMField[]

  // Record inseriti in questo CRM
  records     CRMRecord[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt

  @@index([companyId])
  @@index([createdById])
  @@index([progettoId])
}

// Campi personalizzati per ogni CRM
model CRMField {
  id          String   @id @default(uuid())

  // CRM di appartenenza
  crmTemplateId String
  crmTemplate   CRMTemplate @relation(fields: [crmTemplateId], references: [id], onDelete: Cascade)

  // Definizione campo
  nome        String   // es: "€ Investiti", "Azienda", "Data Primo Contatto"
  tipo        String   // 'text', 'number', 'currency', 'date', 'select', 'multiselect', 'contact', 'boolean'
  descrizione String?

  // Ordine di visualizzazione
  ordine      Int      @default(0)

  // Configurazione campo
  obbligatorio Boolean  @default(false)

  // Opzioni per select/multiselect (JSON array)
  opzioni     String   @default("[]") // es: ["Cliente", "Prospect", "Ex-Cliente"]

  // Valore di default
  valoreDefault String?

  // Se true, questo campo verrà sommato nelle statistiche (per number/currency)
  isAggregabile Boolean @default(false)

  // Se true, questo campo verrà mostrato come statistica principale (es: totale investimenti)
  isStatPrincipale Boolean @default(false)

  createdAt   DateTime @default(now())

  @@index([crmTemplateId])
  @@index([ordine])
}

// Record/Cliente inserito in un CRM
model CRMRecord {
  id          String   @id @default(uuid())

  // CRM di appartenenza
  crmTemplateId String
  crmTemplate   CRMTemplate @relation(fields: [crmTemplateId], references: [id], onDelete: Cascade)

  // Dati del record (JSON con chiavi = nomi campi, valori = valori inseriti)
  dati        String   @default("{}") // es: { "€ Investiti": "50000", "Azienda": "Acme Corp", "Data Primo Contatto": "2025-01-15" }

  // Contatto collegato (opzionale - se creato da contatto esistente)
  contactId   String?

  // Chi ha creato il record
  createdById String

  // Azienda (isolamento dati)
  companyId   String

  // Note aggiuntive
  note        String?

  // Tags personalizzati
  tags        String   @default("[]")

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([crmTemplateId])
  @@index([contactId])
  @@index([createdById])
  @@index([companyId])
}

// ===================================
// SISTEMA PREVENTIVI CON AI
// ===================================

// Preventivi generati automaticamente dall'AI
model Preventivo {
  id          String   @id @default(uuid())

  // Informazioni cliente
  nomeCliente     String   // Nome o Azienda del cliente
  emailCliente    String?
  telefonoCliente String?

  // Collegamento a contatto esistente (opzionale)
  contactId       String?

  // Informazioni azienda che emette il preventivo
  aziendaEmittente String
  logoAzienda      String?  // URL logo

  // Prodotti e link
  linkProdotti    String   @default("[]") // Array JSON di link prodotti online
  linkImmagini    String   @default("[]") // Array JSON di link immagini prodotti

  // Array di prodotti - JSON: [{ codiceArticolo, nome, descrizione, prezzo, quantita, caratteristiche, funzionalita }]
  prodotti        String   @default("[]")

  // Dati estratti dall'AI (legacy - mantenuti per compatibilità)
  nomeProdotto        String?
  descrizioneProdotto String?  // Testo lungo
  caratteristiche     String   @default("[]") // Array JSON di caratteristiche
  funzionalita        String   @default("[]") // Array JSON di funzionalità
  compatibilita       String   @default("[]") // Array JSON dispositivi compatibili
  vantaggi            String   @default("[]") // Array JSON di vantaggi
  riconoscimenti      String   @default("[]") // Array JSON di riconoscimenti/certificazioni

  // Prezzo totale e sconto
  prezzoOriginale Float    // Prezzo totale base (somma prezzi prodotti)
  percentualeSconto Float  @default(0) // % di sconto personalizzato
  prezzoFinale    Float    // Prezzo finale dopo sconto

  // Cosa include il prodotto
  cosaRicevi      String   @default("[]") // Array JSON di cosa ricevi

  // Procedura d'acquisto
  passaggiAcquisto String  @default("[]") // Array JSON di step per acquisto

  // Garanzie
  garanzie        String   @default("[]") // Array JSON di garanzie offerte

  // Stato del preventivo
  stato           String   @default("bozza") // 'bozza', 'inviato', 'approvato', 'rifiutato'

  // File generati
  urlPdf          String?  // URL del PDF generato
  urlExcel        String?  // URL dell'Excel generato

  // Validità preventivo
  dataEmissione   DateTime @default(now())
  dataScadenza    DateTime? // Scadenza validità preventivo

  // Note aggiuntive
  noteAggiuntive  String?

  // Chi ha creato il preventivo
  createdById     String

  // Azienda (isolamento dati)
  companyId       String

  // AI metadata
  aiPromptUsato   String?  // Prompt usato per estrazione dati
  aiModel         String?  @default("gpt-4") // Modello AI usato
  aiProcessedAt   DateTime? // Quando l'AI ha processato i dati

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([companyId])
  @@index([createdById])
  @@index([contactId])
  @@index([stato])
  @@index([dataEmissione])
}

// ===================================
// SISTEMA NEWSLETTER CON AI
// ===================================

// Newsletter con HTML editor e invio automatico
model Newsletter {
  id          String   @id @default(uuid())

  // Informazioni newsletter
  nome        String   // Nome interno della newsletter
  oggetto     String   // Oggetto email
  contenutoHTML String  // Contenuto HTML completo della newsletter

  // Anteprima testo
  anteprimaTesto String? // Testo preview per client email

  // Stato
  stato       String   @default("bozza") // 'bozza', 'programmata', 'inviata', 'in_invio', 'errore'

  // Programmazione invio
  tipoProgrammazione String @default("manuale") // 'manuale', 'ricorrente', 'evento_promozionale'
  dataProgrammata    DateTime? // Data/ora programmata per invio

  // Ricorrenza (se tipoProgrammazione = 'ricorrente')
  ricorrenza         String?  @default("{}") // JSON: { tipo: 'giornaliero'|'settimanale'|'mensile', giorni: [1,2,3], ora: '09:00' }
  isRicorrente       Boolean  @default(false)

  // Evento promozionale AI (se tipoProgrammazione = 'evento_promozionale')
  eventoPromozionale String?  // 'black_friday', 'cyber_monday', 'natale', 'estate', 'custom'
  dataEventoInizio   DateTime?
  dataEventoFine     DateTime?

  // Destinatari
  tipoDestinatari    String   @default("contatti_interni") // 'contatti_interni', 'lista_esterna', 'entrambi'
  contattiInterni    String   @default("[]") // Array JSON di contact IDs interni
  listaEsterna       String   @default("[]") // Array JSON di email esterne caricate

  // Filtri destinatari (opzionale)
  filtriDestinatari  String   @default("{}") // JSON: { tags: [], aziende: [], ruoli: [] }

  // Statistiche invio
  totaleDestinatari  Int      @default(0)
  totaleInviati      Int      @default(0)
  totaleAperti       Int      @default(0) // Future: tracking aperture
  totaleClick        Int      @default(0) // Future: tracking click

  // Date invio
  dataUltimoInvio    DateTime?
  dataProssimoInvio  DateTime? // Per newsletter ricorrenti

  // AI Features
  aiGenerato         Boolean  @default(false) // Se generata dall'AI
  aiPromptUsato      String?  // Prompt usato per generazione
  aiAnalisiEvento    String?  @default("{}") // JSON con analisi AI dell'evento promozionale
  aiSuggerimenti     String?  @default("[]") // Array JSON di suggerimenti AI

  // Alert AI (per notificare admin quando è il momento di inviare)
  aiAlertInviato     Boolean  @default(false)
  aiAlertData        DateTime?

  // Chi ha creato la newsletter
  createdById        String

  // Azienda (isolamento dati)
  companyId          String

  // Log invii
  invii              NewsletterInvio[]

  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@index([companyId])
  @@index([createdById])
  @@index([stato])
  @@index([tipoProgrammazione])
  @@index([dataProgrammata])
  @@index([eventoPromozionale])
  @@index([isRicorrente])
}

// Log degli invii newsletter
model NewsletterInvio {
  id            String   @id @default(uuid())

  // Newsletter di riferimento
  newsletterId  String
  newsletter    Newsletter @relation(fields: [newsletterId], references: [id], onDelete: Cascade)

  // Informazioni invio
  dataInvio     DateTime @default(now())
  stato         String   @default("in_coda") // 'in_coda', 'inviato', 'fallito', 'rimbalzato'

  // Destinatario
  emailDestinatario String
  nomeDestinatario  String?

  // Tracking (future)
  aperto        Boolean  @default(false)
  dataApertura  DateTime?
  clickCount    Int      @default(0)

  // Errori
  errore        String?  // Messaggio di errore se fallito

  @@index([newsletterId])
  @@index([emailDestinatario])
  @@index([stato])
  @@index([dataInvio])
}
